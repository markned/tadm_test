<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiz App</title>
    <!-- Tailwind CSS для стилизации -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React и ReactDOM через CDN -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel для компиляции JSX в браузере -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap');
        body { font-family: 'Inter', sans-serif; }
        /* Плавные переходы для кнопок */
        .transition-all { transition: all 0.2s ease-in-out; }
    </style>
</head>
<body class="bg-slate-50">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useRef } = React;

        // Встроенные SVG иконки для исключения ошибок CDN
        const RefreshCw = () => (
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M3 21v-5h5"/></svg>
        );
        const ChevronLeft = () => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m15 18-6-6 6-6"/></svg>
        );
        const ChevronRight = () => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m9 18 6-6-6-6"/></svg>
        );
        const CheckCircle = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" className={className} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>
        );
        const XCircle = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" className={className} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <circle cx="12" cy="12" r="10" />
                <path d="M15 9l-6 6" />
                <path d="M9 9l6 6" />
            </svg>
        );
        const HelpCircle = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" className={className} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <circle cx="12" cy="12" r="10" />
                <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 2-3 4" />
                <path d="M12 17h.01" />
            </svg>
        );
        const Eye = () => (
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/></svg>
        );
        const BookOpen = () => (
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></svg>
        );
        const Info = () => (
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>
        );

        // Configuration and data will be loaded from test folder via fetch API
        // Test selection: get from URL parameter or use default
        const getTestIdFromURL = () => {
            const params = new URLSearchParams(window.location.search);
            return params.get('test') || 'C_TADM_23';
        };

        // ===== Utility Functions =====
        /**
         * Safely converts a value to a number, with fallback
         */
        function safeNumber(value, fallback = 0) {
            const num = typeof value === 'number' && isFinite(value) && !isNaN(value) ? value : Number(value);
            return isFinite(num) && !isNaN(num) ? num : fallback;
        }

        /**
         * Safely converts a value to a string, with fallback
         */
        function safeString(value, fallback = '') {
            return value != null ? String(value) : fallback;
        }

        /**
         * Safely checks if value is a valid array
         */
        function safeArray(value) {
            return Array.isArray(value) ? value : [];
        }

        /**
         * Safely gets array length
         */
        function safeLength(value) {
            return safeArray(value).length;
        }

        /**
         * Counts correct answers from statusById
         */
        function countCorrect(ids, statusById) {
            if (!safeArray(ids).length || !statusById || typeof statusById !== 'object') return 0;
            try {
                return ids.filter(id => id && statusById[id] === 'correct').length;
            } catch (e) {
                return 0;
            }
        }

        /**
         * Calculates percentage safely
         */
        function safePercent(part, total, fallback = 0) {
            if (!safeArray(total).length) return fallback;
            const pct = (safeNumber(part) / safeLength(total)) * 100;
            return safeNumber(pct, fallback);
        }

        // Random shuffle helpers (new random order on each page load / rebuild)

        /**
         * Shuffles array using Fisher-Yates algorithm
         */
        function shuffleArray(array, rng = Math.random) {
            const result = [...array];
            for (let i = result.length - 1; i > 0; i--) {
                const j = Math.floor(rng() * (i + 1));
                [result[i], result[j]] = [result[j], result[i]];
            }
            return result;
        }

        /**
         * Shuffles question options and remaps correct answer indices
         */
        function shuffleQuestionOptions(q) {
            if (!q || !Array.isArray(q.options)) return q;
            const idxs = q.options.map((_, i) => i);
            const shuffledIdxs = shuffleArray(idxs);

            const inv = {};
            shuffledIdxs.forEach((oldIdx, newIdx) => { inv[oldIdx] = newIdx; });

            const newOptions = shuffledIdxs.map(i => q.options[i]);
            const newCorrect = (q.correctAnswerIndex || []).map(oldIdx => inv[oldIdx]).filter(idx => idx !== undefined);

            return { ...q, options: newOptions, correctAnswerIndex: newCorrect };
        }

        /**
         * Formats category name for display
         */
        function formatCategoryName(category, categoryDisplayNames = {}) {
            if (!category) return "Unknown";
            return categoryDisplayNames[category] || category.replace(/_/g, " ");
        }

        /**
         * Groups questions by category
         */
        function groupQuestionsByCategory(questions) {
            const byCategory = {};
            safeArray(questions).forEach(q => {
                const cat = q.category || "System_Administration"; // default category
                if (!byCategory[cat]) byCategory[cat] = [];
                byCategory[cat].push(q);
            });
            return byCategory;
        }

        /**
         * Samples questions with topic-based distribution
         */
        function sampleQuestions(sizeValue, quizData = [], topicDistribution = {}) {
            const count = parseInt(sizeValue, 10);
            const all = safeArray(quizData);

            // All mode: shuffle all questions
            const isAllMode = !Number.isFinite(count) || count <= 0 || count >= all.length;
            if (isAllMode) {
                return shuffleArray(all).map(shuffleQuestionOptions);
            }

            // Check if questions have categories
            const hasCategories = all.some(q => q.category);
            
            if (!hasCategories || !topicDistribution || Object.keys(topicDistribution).length === 0) {
                // Fallback: simple random selection if no categories or no distribution
                const picked = shuffleArray(all).slice(0, count);
                return picked.map(shuffleQuestionOptions);
            }

            // Topic-based distribution
            const byCategory = groupQuestionsByCategory(all);
            const picked = [];
            const categoryCounts = {};

            // Calculate initial distribution
            Object.keys(topicDistribution).forEach(cat => {
                const percentage = topicDistribution[cat];
                const categoryQuestions = safeArray(byCategory[cat]);
                const numFromCategory = Math.round(count * percentage / 100);
                categoryCounts[cat] = Math.min(numFromCategory, categoryQuestions.length);
            });

            // Adjust to ensure exactly 'count' questions
            const totalAllocated = Object.values(categoryCounts).reduce((a, b) => a + b, 0);
            if (totalAllocated < count) {
                // Distribute remaining to categories with available questions
                const remaining = count - totalAllocated;
                const categoriesWithSpace = Object.keys(TOPIC_DISTRIBUTION).filter(cat => {
                    const allocated = categoryCounts[cat] || 0;
                    const available = safeArray(byCategory[cat]).length;
                    return allocated < available;
                });

                for (let i = 0; i < remaining && categoriesWithSpace.length > 0; i++) {
                    const cat = categoriesWithSpace[i % categoriesWithSpace.length];
                    const available = safeArray(byCategory[cat]).length;
                    if (categoryCounts[cat] < available) {
                        categoryCounts[cat]++;
                    }
                }
            } else if (totalAllocated > count) {
                // Reduce if over-allocated
                const excess = totalAllocated - count;
                const categoriesToReduce = Object.keys(categoryCounts).filter(cat => categoryCounts[cat] > 0);
                for (let i = 0; i < excess && categoriesToReduce.length > 0; i++) {
                    const cat = categoriesToReduce[i % categoriesToReduce.length];
                    if (categoryCounts[cat] > 0) {
                        categoryCounts[cat]--;
                    }
                }
            }

            // Pick questions from each category
            Object.keys(categoryCounts).forEach(cat => {
                const numToPick = categoryCounts[cat];
                const categoryQuestions = shuffleArray([...safeArray(byCategory[cat])]);
                picked.push(...categoryQuestions.slice(0, numToPick));
            });

            // Shuffle final selection to mix categories
            return shuffleArray(picked).map(shuffleQuestionOptions);
        }

        function App() {
            // Get test ID from URL or use default
            const [testId] = useState(() => getTestIdFromURL());
            const testPath = `${testId}/`;

            // ---- state ----
            const [config, setConfig] = useState(null);
            const [quizData, setQuizData] = useState([]);
            const [isLoadingData, setIsLoadingData] = useState(true);
            const [dataLoadError, setDataLoadError] = useState(null);
            const [quizSize, setQuizSize] = useState('80'); // Will be updated from config
            const [questions, setQuestions] = useState([]);

            // phase: main -> (resultsMain -> review -> resultsReview) OR main -> repeat -> perfect
            const [phase, setPhase] = useState('main'); // 'main' | 'review' | 'repeat' | 'resultsMain' | 'resultsReview' | 'perfect'
            const [tab, setTab] = useState('quiz'); // 'quiz' | 'knowledge'
            const [examMode, setExamMode] = useState(false); // false = Study Mode (default), true = Exam Mode
            const repeatWrongUntilCorrect = !examMode; // In exam mode, repeat is disabled

            const [activeIndex, setActiveIndex] = useState(0);
            const [answersById, setAnswersById] = useState({});
            const [lockedIds, setLockedIds] = useState(new Set()); // locked (submitted) in current pass
            const [statusById, setStatusById] = useState({}); // { [id]: 'correct' | 'wrong' } ; missing => unanswered

            const [reviewIds, setReviewIds] = useState([]);
            const [repeatRemainingIds, setRepeatRemainingIds] = useState([]);
            const [repeatPassIds, setRepeatPassIds] = useState([]);

            const [knowledgeQuery, setKnowledgeQuery] = useState('');
            const [isQuestionListOpen, setIsQuestionListOpen] = useState(true);

            const [hint, setHint] = useState({ qid: null, until: 0 }); // temporary hint for correct options
            const autoNextTimerRef = useRef(null);
            const knowledgeQuestionRefs = useRef({}); // Refs for Knowledge Base questions for scrolling

            // confirmation modal
            const [confirmState, setConfirmState] = useState({ open: false, title: '', message: '' });
            const confirmActionRef = useRef(null);

            // result modal (for normal mode finish)
            const [resultModal, setResultModal] = useState({ 
                open: false, 
                score: 0, 
                correct: 0, 
                total: 0,
                categoryStats: null, // { [category]: { total: number, correct: number, percent: number } }
                wrongAnswers: null // Array of questions with wrong answers
            });

            // skipped questions modal
            const [skippedModal, setSkippedModal] = useState({ open: false });
            
            // view wrong answers modal
            const [wrongAnswersModal, setWrongAnswersModal] = useState({ open: false });

            // shuffled options for all phases (shuffled on init, reset, and each repeat cycle)
            const [shuffledById, setShuffledById] = useState({}); // { [id]: { options: string[], correct: number[] } }

            // Calculate time limit for quiz size (disabled for "All")
            const getTimeLimitSecondsForSize = (sizeValue, quizDataArray = []) => {
                const count = parseInt(sizeValue, 10);
                if (!Number.isFinite(count) || count <= 0) return null;
                if (count >= safeLength(quizDataArray)) return null;
                return count * TIME_PER_QUESTION_SEC;
            };
            const [timeLeftSec, setTimeLeftSec] = useState(null);

            // ---- helpers ----
            const questionById = useMemo(() => {
                try {
                    const m = {};
                    safeArray(questions).forEach(q => { if (q?.id) m[q.id] = q; });
                    return m;
                } catch (e) {
                    return {};
                }
            }, [questions]);

            const formatTime = (totalSeconds) => {
                const s = Math.max(0, totalSeconds | 0);
                const h = Math.floor(s / 3600);
                const m = Math.floor((s % 3600) / 60);
                const ss = s % 60;
                const pad2 = (n) => String(n).padStart(2, '0');
                return `${h}:${pad2(m)}:${pad2(ss)}`;
            };

            const normalizeIdxs = (arr) => {
                const a = safeArray(arr);
                return Array.from(new Set(a)).sort((x, y) => x - y);
            };
            const isSameSet = (a, b) => {
                const aa = normalizeIdxs(a);
                const bb = normalizeIdxs(b);
                if (aa.length !== bb.length) return false;
                const setB = new Set(bb);
                return aa.every(v => setB.has(v));
            };
            const isCorrectForQuestion = (q, answers = answersById) => {
                if (!q?.id) return false;
                const userAnswer = answers[q.id] || [];
                // Always use shuffled correct indices if available
                if (shuffledById[q.id]) {
                    const shuffled = shuffledById[q.id];
                    const correctIndices = shuffled.correct || [];
                    return isSameSet(userAnswer, correctIndices);
                }
                // Fallback to original (should not happen if shuffle is initialized)
                const originalCorrect = safeArray(q.correctAnswerIndex);
                return isSameSet(userAnswer, originalCorrect);
            };

            // Shuffle question options and remap correct indices
            // Returns: { options: string[], correct: number[] }
            // correct is always an array (even for single choice)
            const shuffleQuestion = (q) => {
                if (!q?.id || !Array.isArray(q.options)) return null;
                
                // Create array of original indices [0, 1, 2, ...]
                const originalIndices = q.options.map((_, i) => i);
                
                // Shuffle indices using Fisher-Yates
                const shuffledIndices = shuffleArray(originalIndices);
                
                // Build shuffled options array
                const shuffledOptions = shuffledIndices.map(i => q.options[i]);
                
                // Create mapping: original index -> new index
                const indexMap = {}; // original -> new
                shuffledIndices.forEach((oldIdx, newIdx) => { indexMap[oldIdx] = newIdx; });
                
                // Remap correct indices: convert original indices to new indices
                const originalCorrect = Array.isArray(q.correctAnswerIndex) ? q.correctAnswerIndex : [q.correctAnswerIndex].filter(i => i !== undefined);
                const remappedCorrect = originalCorrect.map(oldIdx => indexMap[oldIdx]).filter(i => i !== undefined).sort((a, b) => a - b);
                
                return {
                    options: shuffledOptions,
                    correct: remappedCorrect
                };
            };

            // Initialize shuffledById for all questions
            const initShuffleAll = (questionsList) => {
                const shuffled = {};
                (questionsList || []).forEach(q => {
                    if (q?.id) {
                        const shuffledData = shuffleQuestion(q);
                        if (shuffledData) shuffled[q.id] = shuffledData;
                    }
                });
                return shuffled;
            };

            // Reshuffle options for specific question IDs (used for repeatWrong new cycle)
            const reshuffleForIds = (ids) => {
                const shuffled = {};
                ids.forEach(id => {
                    const q = questionById[id];
                    if (q) {
                        const shuffledData = shuffleQuestion(q);
                        if (shuffledData) shuffled[id] = shuffledData;
                    }
                });
                return shuffled;
            };

            const getStatus = (id) => statusById?.[id] || 'unanswered';

            const allIds = useMemo(() => {
                try {
                    return safeArray(questions).map(q => q?.id).filter(Boolean);
                } catch (e) {
                    return [];
                }
            }, [questions]);
            const activeIds = useMemo(() => {
                if (phase === 'review') return reviewIds;
                if (phase === 'repeat') return repeatPassIds;
                return allIds;
            }, [phase, allIds, reviewIds, repeatPassIds]);

            const activeQuestions = useMemo(() => activeIds.map(id => questionById[id]).filter(Boolean), [activeIds, questionById]);

            const hasQuestions = activeQuestions.length > 0;
            const safeIndex = hasQuestions ? Math.min(activeIndex, activeQuestions.length - 1) : 0;
            const currentQuestion = hasQuestions ? activeQuestions[safeIndex] : null;
            const currentId = currentQuestion?.id || null;
            
            // Get options (always use shuffled if available)
            const currentOptions = useMemo(() => {
                if (!currentQuestion?.id) return [];
                if (shuffledById[currentQuestion.id]) {
                    return shuffledById[currentQuestion.id].options || [];
                }
                // Fallback to original (should not happen if shuffle is initialized)
                return currentQuestion.options || [];
            }, [currentQuestion, shuffledById]);
            
            // Get correct indices for current question (always use shuffled if available)
            const currentCorrectIndices = useMemo(() => {
                if (!currentQuestion?.id) return [];
                if (shuffledById[currentQuestion.id]) {
                    return shuffledById[currentQuestion.id].correct || [];
                }
                // Fallback to original (should not happen if shuffle is initialized)
                const originalCorrect = Array.isArray(currentQuestion.correctAnswerIndex) 
                    ? currentQuestion.correctAnswerIndex 
                    : [currentQuestion.correctAnswerIndex].filter(i => i !== undefined);
                return originalCorrect;
            }, [currentQuestion, shuffledById]);

            const requiredSelections = currentQuestion?.type === 'multiple'
                ? (currentQuestion.correctAnswerIndex?.length || 2)
                : 1;

            const isLocked = currentId ? lockedIds.has(currentId) : false;
            const isHintActive = !examMode && !isLocked && hint?.qid === currentId && typeof hint?.until === 'number' && hint.until > Date.now();
            const isLast = safeIndex === activeQuestions.length - 1;

            const activeCorrectCount = useMemo(() => {
                let c = 0;
                for (const id of activeIds) if (getStatus(id) === 'correct') c++;
                return c;
            }, [activeIds, statusById]);

            const computeWrongIdsFromStatus = (ids) => safeArray(ids).filter(id => getStatus(id) !== 'correct');
            const clearAnswersForIds = (ids) => {
                const setIds = new Set(safeArray(ids));
                if (!setIds.size) return;
                setAnswersById(prev => {
                    const next = { ...prev };
                    setIds.forEach(id => { delete next[id]; });
                    return next;
                });
            };

            const resetRunState = (newQuestions) => {
                if (autoNextTimerRef.current) {
                    window.clearTimeout(autoNextTimerRef.current);
                    autoNextTimerRef.current = null;
                }
                setQuestions(newQuestions);
                // Initialize shuffledById for all questions on reset/init
                setShuffledById(initShuffleAll(newQuestions));
                setPhase('main');
                setTab('quiz');
                setActiveIndex(0);
                setAnswersById({});
                setLockedIds(new Set());
                setStatusById({});
                setReviewIds([]);
                setRepeatRemainingIds([]);
                setRepeatPassIds([]);
                setKnowledgeQuery('');
                setIsQuestionListOpen(true);
                setHint({ qid: null, until: 0 });
                setResultModal({ open: false, score: 0, correct: 0, total: 0, categoryStats: null, wrongAnswers: null });
                setSkippedModal({ open: false });
                const limit = getTimeLimitSecondsForSize(quizSize, quizData, config?.timePerQuestionSec || 135);
                setTimeLeftSec(typeof limit === 'number' ? limit : null);
            };

            // Find first unanswered question index in active set
            const findFirstUnansweredIndex = (ids) => {
                for (let i = 0; i < ids.length; i++) {
                    if (getStatus(ids[i]) === 'unanswered') return i;
                }
                return -1;
            };

            // ---- effects ----
            // Load configuration and quiz data from test folder
            useEffect(() => {
                setIsLoadingData(true);
                setDataLoadError(null);
                
                // Load configuration first
                fetch(`${testPath}config.json`)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Failed to load config: ${response.status} ${response.statusText}`);
                        }
                        return response.json();
                    })
                    .then(configData => {
                        setConfig(configData);
                        // Update page title
                        document.title = configData.testName || 'Quiz App';
                        // Set default quiz size from config
                        setQuizSize(String(configData.defaultQuizSize || 80));
                        
                        // Then load quiz data
                        return fetch(`${testPath}quiz-data.json`);
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Failed to load quiz data: ${response.status} ${response.statusText}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        setQuizData(data);
                        setIsLoadingData(false);
                    })
                    .catch(error => {
                        console.error('Error loading test data:', error);
                        setDataLoadError(error.message);
                        setIsLoadingData(false);
                    });
                // eslint-disable-next-line react-hooks/exhaustive-deps
            }, [testId]);

            useEffect(() => {
                if (quizData.length === 0 || !config) return; // Wait for data and config to load
                // rebuild when quiz size changes
                const newQs = sampleQuestions(quizSize, quizData, config.topicDistribution || {});
                resetRunState(newQs);
                const limit = getTimeLimitSecondsForSize(quizSize, quizData, config.timePerQuestionSec || 135);
                setTimeLeftSec(typeof limit === 'number' ? limit : null);
                // eslint-disable-next-line react-hooks/exhaustive-deps
            }, [quizSize, quizData, config]);

            // Initialize shuffledById on first load if empty
            useEffect(() => {
                if (questions.length > 0) {
                    // Always ensure shuffledById is complete for all questions
                    const currentShuffled = { ...shuffledById };
                    let needsUpdate = false;
                    questions.forEach(q => {
                        if (q?.id && !currentShuffled[q.id]) {
                            const shuffledData = shuffleQuestion(q);
                            if (shuffledData) {
                                currentShuffled[q.id] = shuffledData;
                                needsUpdate = true;
                            }
                        }
                    });
                    if (needsUpdate || Object.keys(shuffledById).length === 0) {
                        setShuffledById(currentShuffled);
                    }
                }
                // eslint-disable-next-line react-hooks/exhaustive-deps
            }, [questions]);

            useEffect(() => {
                // keep index in bounds
                if (activeQuestions.length && activeIndex >= activeQuestions.length) setActiveIndex(0);
            }, [activeQuestions.length, activeIndex]);

            // Scroll to current question in Knowledge Base when it changes
            useEffect(() => {
                if (tab === 'knowledge' && currentId && knowledgeQuestionRefs.current[currentId]) {
                    const element = knowledgeQuestionRefs.current[currentId];
                    element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }, [currentId, tab]);

            useEffect(() => {
                // cleanup pending auto-next timer on unmount
                return () => {
                    if (autoNextTimerRef.current) {
                        window.clearTimeout(autoNextTimerRef.current);
                        autoNextTimerRef.current = null;
                    }
                };
            }, []);

            useEffect(() => {
                // timer runs only while doing quiz-like phases AND not in Study tab
                const isTimed =
                    typeof timeLeftSec === 'number' &&
                    timeLeftSec > 0 &&
                    tab === 'quiz' &&
                    (phase === 'main' || phase === 'review' || phase === 'repeat');
                if (!isTimed) return;
                const t = window.setInterval(() => setTimeLeftSec(s => (typeof s === 'number' ? Math.max(0, s - 1) : s)), 1000);
                return () => window.clearInterval(t);
            }, [timeLeftSec, tab, phase]);

            useEffect(() => {
                if (typeof timeLeftSec !== 'number') return;
                if (timeLeftSec > 0) return;
                // time over -> stop and show main results (simple predictable behavior)
                if (phase === 'main' || phase === 'review' || phase === 'repeat') {
                    const wrong = computeWrongIdsFromStatus(allIds);
                    setReviewIds(wrong);
                    setPhase('resultsMain');
                    setLockedIds(new Set());
                }
            }, [timeLeftSec, phase, allIds]);

            useEffect(() => {
                // Auto-advance to next repeat cycle when last question is locked in repeat phase
                if (phase === 'repeat' && isLast && isLocked && repeatRemainingIds.length > 0) {
                    // Small delay to let user see the result
                    const timer = window.setTimeout(() => {
                        const nextPass = [...repeatRemainingIds];
                        // Reshuffle options for remaining wrong questions
                        const shuffled = reshuffleForIds(nextPass);
                        setShuffledById(prev => ({ ...prev, ...shuffled }));
                        setRepeatPassIds(nextPass);
                        setActiveIndex(0);
                        setLockedIds(new Set());
                        setHint({ qid: null, until: 0 });
                        clearAnswersForIds(nextPass);
                    }, config?.autoNextDelayMs || 2000);
                    return () => window.clearTimeout(timer);
                }
                // If no remaining wrong questions, show perfect modal
                if (phase === 'repeat' && isLast && isLocked && repeatRemainingIds.length === 0) {
                    const timer = window.setTimeout(() => {
                        const correct = allIds.filter(id => getStatus(id) === 'correct').length;
                        setResultModal({ open: true, score: 100, correct: allIds.length, total: allIds.length });
                    }, config?.autoNextDelayMs || 2000);
                    return () => window.clearTimeout(timer);
                }
                // eslint-disable-next-line react-hooks/exhaustive-deps
            }, [phase, isLast, isLocked, repeatRemainingIds.length]);

            // ---- actions ----
            const onRestart = () => resetRunState(sampleQuestions(quizSize, quizData, config?.topicDistribution || {}));

            const askConfirm = ({ title, message, onConfirm }) => {
                confirmActionRef.current = onConfirm || null;
                setConfirmState({ open: true, title, message });
            };

            const closeConfirm = () => {
                confirmActionRef.current = null;
                setConfirmState({ open: false, title: '', message: '' });
            };

            const confirmYes = () => {
                const fn = confirmActionRef.current;
                closeConfirm();
                if (typeof fn === 'function') fn();
            };

            const requestRestart = () => {
                askConfirm({
                    title: 'Restart quiz?',
                    message: 'Your current progress and answers will be lost. Continue?',
                    onConfirm: () => onRestart()
                });
            };

            const requestSetQuizSize = (nextSize) => {
                if (String(nextSize) === String(quizSize)) return;
                askConfirm({
                    title: 'Change question set?',
                    message: 'Changing the set will restart the quiz and clear your progress. Continue?',
                    onConfirm: () => setQuizSize(String(nextSize))
                });
            };

            const requestSetExamMode = (newExamMode) => {
                if (newExamMode === examMode) return;
                const modeName = newExamMode ? 'Exam Mode' : 'Study Mode';
                askConfirm({
                    title: `Switch to ${modeName}?`,
                    message: `Switching to ${modeName} will restart the quiz and clear your progress. Continue?`,
                    onConfirm: () => {
                        setExamMode(newExamMode);
                        // Force quiz tab in exam mode
                        if (newExamMode) {
                            setTab('quiz');
                        }
                        // Restart quiz when switching modes
                        resetRunState(sampleQuestions(quizSize, quizData, config?.topicDistribution || {}));
                    }
                });
            };

            const goToIndex = (nextIdx) => {
                if (autoNextTimerRef.current) {
                    window.clearTimeout(autoNextTimerRef.current);
                    autoNextTimerRef.current = null;
                }
                setActiveIndex(nextIdx);
            };

            const onToggleOption = (idx) => {
                // In exam mode, allow changing answers even after submit
                if (!currentId || (isLocked && !(examMode && phase === 'main'))) return;
                const selected = answersById[currentId] || [];
                if (currentQuestion?.type === 'single') {
                    setAnswersById(prev => ({ ...prev, [currentId]: [idx] }));
                    return;
                }
                if (selected.includes(idx)) {
                    setAnswersById(prev => ({ ...prev, [currentId]: selected.filter(i => i !== idx) }));
                    return;
                }
                if (selected.length >= requiredSelections) return;
                setAnswersById(prev => ({ ...prev, [currentId]: [...selected, idx] }));
            };

            const onShowHint = () => {
                if (!currentId || isLocked) return;
                const hintMs = config?.hintMs || 50;
                const until = Date.now() + hintMs;
                setHint({ qid: currentId, until });
                window.setTimeout(() => {
                    setHint(h => (h?.qid === currentId && h?.until === until ? { qid: null, until: 0 } : h));
                }, hintMs);
            };

            const onSubmit = () => {
                if (!currentId) return;
                if (isLocked) return;

                // In exam mode, don't lock question or check correctness - allow answer changes
                if (examMode && phase === 'main') {
                    // Just auto-advance to next question without locking or checking
                    if (safeIndex < activeQuestions.length - 1) {
                        if (autoNextTimerRef.current) {
                            window.clearTimeout(autoNextTimerRef.current);
                            autoNextTimerRef.current = null;
                        }
                        const nextIdx = Math.min(activeQuestions.length - 1, safeIndex + 1);
                        const delay = 100;
                        autoNextTimerRef.current = window.setTimeout(() => {
                            autoNextTimerRef.current = null;
                            setHint({ qid: null, until: 0 });
                            setActiveIndex(nextIdx);
                        }, delay);
                    }
                    return;
                }

                // In study mode, check and lock as usual
                const correctNow = isCorrectForQuestion(currentQuestion, answersById);
                setStatusById(prev => ({ ...prev, [currentId]: correctNow ? 'correct' : 'wrong' }));
                setLockedIds(prev => new Set(prev).add(currentId));
                if (phase === 'repeat' && correctNow) {
                    setRepeatRemainingIds(prev => (prev || []).filter(id => id !== currentId));
                }

                if (safeIndex < activeQuestions.length - 1) {
                    if (autoNextTimerRef.current) {
                        window.clearTimeout(autoNextTimerRef.current);
                        autoNextTimerRef.current = null;
                    }
                    const nextIdx = Math.min(activeQuestions.length - 1, safeIndex + 1);
                    const delay = examMode ? 100 : (config?.autoNextDelayMs || 2000);
                    autoNextTimerRef.current = window.setTimeout(() => {
                        autoNextTimerRef.current = null;
                        setHint({ qid: null, until: 0 });
                        setActiveIndex(nextIdx);
                    }, delay);
                }
            };

            const onFinish = () => {
                // Finish the current phase (separate from Submit)
                // In exam mode, allow finish even if questions are not locked
                if (examMode && phase === 'main') {
                    // Check all answers and set statuses for exam mode
                    allIds.forEach(id => {
                        const q = questionById[id];
                        if (!q || !q.id) return;
                        // Try to get answer with both id and q.id to handle potential type mismatches
                        const userAnswer = answersById[id] || answersById[q.id] || answersById[String(id)] || answersById[String(q.id)];
                        // If no answer provided, mark as wrong
                        if (!userAnswer || userAnswer.length === 0) {
                            setStatusById(prev => ({ ...prev, [id]: 'wrong' }));
                            return;
                        }
                        // Check if shuffled data exists for this question (try both id and q.id)
                        const shuffled = shuffledById[id] || shuffledById[q.id] || shuffledById[String(id)] || shuffledById[String(q.id)];
                        if (shuffled && shuffled.correct) {
                            // Use shuffled correct indices
                            const correctNow = isSameSet(userAnswer, shuffled.correct);
                            setStatusById(prev => ({ ...prev, [id]: correctNow ? 'correct' : 'wrong' }));
                        } else {
                            // Fallback to original correct indices (should not happen if shuffle is initialized)
                            const originalCorrect = safeArray(q.correctAnswerIndex);
                            const correctNow = isSameSet(userAnswer, originalCorrect);
                            setStatusById(prev => ({ ...prev, [id]: correctNow ? 'correct' : 'wrong' }));
                        }
                    });
                    setLockedIds(new Set(allIds)); // Lock all questions after checking
                } else {
                    if (!isLocked || !isLast) return;
                }

                if (phase === 'main') {
                    // Check for unanswered questions (only show modal if not in exam mode)
                    if (!examMode) {
                        const unansweredIdx = findFirstUnansweredIndex(allIds);
                        if (unansweredIdx >= 0) {
                            setSkippedModal({ open: true });
                            return;
                        }
                    }

                    const wrong = computeWrongIdsFromStatus(allIds);
                    setReviewIds(wrong);
                    if (repeatWrongUntilCorrect) {
                        if (!wrong.length) {
                            // All correct - show perfect modal
                            const categoryStats = examMode ? calculateCategoryStats(allIds) : null;
                            setResultModal({ 
                                open: true, 
                                score: 100, 
                                correct: allIds.length, 
                                total: allIds.length,
                                categoryStats: categoryStats,
                                wrongAnswers: null
                            });
                            return;
                        }
                        // Start repeat cycle - reshuffle options for all wrong questions
                        const shuffled = reshuffleForIds(wrong);
                        setShuffledById(prev => ({ ...prev, ...shuffled }));
                        setPhase('repeat');
                        setRepeatRemainingIds(wrong);
                        setRepeatPassIds(wrong);
                        setActiveIndex(0);
                        setLockedIds(new Set());
                        setHint({ qid: null, until: 0 });
                        clearAnswersForIds(wrong);
                        return;
                    }
                    // Normal mode or Exam mode - show result modal
                    // In exam mode, compute correct count directly (not from statusById which updates asynchronously)
                    const correct = examMode 
                        ? allIds.filter(id => isAnswerCorrect(id)).length
                        : allIds.filter(id => getStatus(id) === 'correct').length;
                    const percent = allIds.length ? (correct / allIds.length) * 100 : 0;
                    const categoryStats = examMode ? calculateCategoryStats(allIds) : null;
                    const wrongAnswers = examMode ? getWrongAnswersDetails(allIds) : null;
                    setResultModal({ 
                        open: true, 
                        score: percent, 
                        correct, 
                        total: allIds.length,
                        categoryStats: categoryStats,
                        wrongAnswers: wrongAnswers
                    });
                    return;
                }

                if (phase === 'review') {
                    setPhase('resultsReview');
                    return;
                }

                if (phase === 'repeat') {
                    if (!repeatRemainingIds.length) {
                        // All wrong questions corrected - show perfect modal
                        const correct = allIds.filter(id => getStatus(id) === 'correct').length;
                        setResultModal({ open: true, score: 100, correct: allIds.length, total: allIds.length });
                        return;
                    }
                    // Start new repeat cycle - reshuffle options for remaining wrong questions
                    const shuffled = reshuffleForIds(repeatRemainingIds);
                    setShuffledById(prev => ({ ...prev, ...shuffled }));
                    const nextPass = [...repeatRemainingIds];
                    setRepeatPassIds(nextPass);
                    setActiveIndex(0);
                    setLockedIds(new Set());
                    setHint({ qid: null, until: 0 });
                    clearAnswersForIds(nextPass);
                }
            };

            const startReviewWrong = () => {
                if (!reviewIds.length) return;
                setPhase('review');
                setTab('quiz');
                setActiveIndex(0);
                setLockedIds(new Set());
                setHint({ qid: null, until: 0 });
                clearAnswersForIds(reviewIds);
            };

            const mainCorrect = useMemo(() => allIds.filter(id => getStatus(id) === 'correct').length, [allIds, statusById]);
            const mainPercent = useMemo(() => (allIds.length ? (mainCorrect / allIds.length) * 100 : 0), [mainCorrect, allIds.length]);

            const reviewFixedCount = useMemo(() => reviewIds.filter(id => getStatus(id) === 'correct').length, [reviewIds, statusById]);

            // Helper function to check if answer is correct (directly, without relying on statusById)
            const isAnswerCorrect = (id) => {
                const q = questionById[id];
                if (!q || !q.id) return false;
                // Try multiple ID formats to find user answer
                const userAnswer = answersById[id] || answersById[q.id] || answersById[String(id)] || answersById[String(q.id)];
                // If no answer provided, it's wrong
                if (!userAnswer || userAnswer.length === 0) return false;
                // Try multiple ID formats to find shuffled data
                const shuffled = shuffledById[id] || shuffledById[q.id] || shuffledById[String(id)] || shuffledById[String(q.id)];
                if (shuffled && shuffled.correct) {
                    // Use shuffled correct indices
                    return isSameSet(userAnswer, shuffled.correct);
                } else {
                    // Fallback to original correct indices
                    const originalCorrect = safeArray(q.correctAnswerIndex);
                    return isSameSet(userAnswer, originalCorrect);
                }
            };

            // Calculate category statistics
            const calculateCategoryStats = (questionIds) => {
                const stats = {};
                safeArray(questionIds).forEach(id => {
                    const q = questionById[id];
                    if (!q) return;
                    const cat = q.category || "System_Administration";
                    if (!stats[cat]) {
                        stats[cat] = { total: 0, correct: 0 };
                    }
                    stats[cat].total++;
                    // Use direct check instead of getStatus to avoid async state issues
                    if (isAnswerCorrect(id)) {
                        stats[cat].correct++;
                    }
                });
                // Calculate percentages
                Object.keys(stats).forEach(cat => {
                    stats[cat].percent = stats[cat].total > 0 
                        ? (stats[cat].correct / stats[cat].total) * 100 
                        : 0;
                });
                return stats;
            };

            // Get wrong answers with details
            const getWrongAnswersDetails = (questionIds) => {
                // Compute wrong answers directly instead of relying on statusById (which updates asynchronously)
                const wrong = safeArray(questionIds).filter(id => {
                    const q = questionById[id];
                    if (!q || !q.id) return false;
                    // Try multiple ID formats to find user answer (same as in onFinish)
                    const userAnswer = answersById[id] || answersById[q.id] || answersById[String(id)] || answersById[String(q.id)];
                    // If no answer provided, it's wrong
                    if (!userAnswer || userAnswer.length === 0) return true;
                    // Try multiple ID formats to find shuffled data (same as in onFinish)
                    const shuffled = shuffledById[id] || shuffledById[q.id] || shuffledById[String(id)] || shuffledById[String(q.id)];
                    if (shuffled && shuffled.correct) {
                        // Use shuffled correct indices
                        return !isSameSet(userAnswer, shuffled.correct);
                    } else {
                        // Fallback to original correct indices
                        const originalCorrect = safeArray(q.correctAnswerIndex);
                        return !isSameSet(userAnswer, originalCorrect);
                    }
                });
                
                return wrong.map(id => {
                    const q = questionById[id];
                    if (!q || !q.id) return null;
                    // Try multiple ID formats to find user answer (same as in onFinish)
                    const userAnswer = answersById[id] || answersById[q.id] || answersById[String(id)] || answersById[String(q.id)] || [];
                    // Try multiple ID formats to find shuffled data (same as in onFinish)
                    const shuffled = shuffledById[id] || shuffledById[q.id] || shuffledById[String(id)] || shuffledById[String(q.id)];
                    const correctIndices = shuffled?.correct || q.correctAnswerIndex;
                    const options = shuffled?.options || q.options;
                    return {
                        id: q.id,
                        question: q.question,
                        category: q.category,
                        options: options,
                        userAnswer: userAnswer,
                        correctAnswer: Array.isArray(correctIndices) ? correctIndices : [correctIndices],
                        explanation: q.explanation
                    };
                }).filter(Boolean);
            };

            // ---- render screens ----
            // Show loading screen while data is being loaded
            if (isLoadingData) {
                return (
                    <div className="min-h-screen flex items-center justify-center p-6 bg-slate-50">
                        <div className="bg-white w-full max-w-md rounded-3xl shadow-xl p-8 text-center space-y-6 border">
                            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto"></div>
                            <h1 className="text-2xl font-bold text-slate-800">Loading Quiz Data...</h1>
                            <p className="text-slate-500 font-medium">Please wait while we load the questions.</p>
                        </div>
                    </div>
                );
            }

            // Show error screen if data failed to load
            if (dataLoadError) {
                return (
                    <div className="min-h-screen flex items-center justify-center p-6 bg-slate-50">
                        <div className="bg-white w-full max-w-md rounded-3xl shadow-xl p-8 text-center space-y-6 border">
                            <XCircle className="w-16 h-16 mx-auto text-red-500" />
                            <h1 className="text-2xl font-bold text-slate-800">Failed to Load Quiz Data</h1>
                            <p className="text-slate-500 font-medium">{dataLoadError}</p>
                            <p className="text-sm text-slate-400">Please make sure quiz-data.json file exists and try refreshing the page.</p>
                            <button 
                                onClick={() => window.location.reload()} 
                                className="w-full py-3 bg-blue-600 text-white rounded-xl font-bold hover:bg-blue-700"
                            >
                                Reload Page
                            </button>
                        </div>
                    </div>
                );
            }

            if (!hasQuestions) {
                return (
                    <div className="min-h-screen bg-slate-50 flex items-center justify-center p-6">
                        <div className="bg-white rounded-2xl shadow-sm border border-slate-200 p-6 max-w-md w-full">
                            <div className="text-lg font-bold text-slate-800">No questions loaded</div>
                            <div className="text-sm text-slate-500 mt-2">Try selecting a set size again or restart.</div>
                            <button onClick={requestRestart} className="mt-4 w-full px-4 py-3 rounded-xl bg-slate-900 text-white font-semibold">
                                Reload
                            </button>
                        </div>
                    </div>
                );
            }

            if (phase === 'perfect') {
                return (
                    <div className="min-h-screen flex items-center justify-center p-6">
                        <div className="bg-white w-full max-w-md rounded-3xl shadow-xl p-8 text-center space-y-6 border">
                            <CheckCircle className="w-16 h-16 mx-auto text-green-500" />
                            <h1 className="text-2xl font-bold">Perfect / All correct</h1>
                            <p className="text-slate-500 font-medium">All wrong answers have been corrected.</p>
                            <button onClick={requestRestart} className="w-full py-3 bg-blue-600 text-white rounded-xl font-bold hover:bg-blue-700">Start Again</button>
                        </div>
                    </div>
                );
            }

            if (phase === 'resultsMain' || phase === 'resultsReview') {
                const isMain = phase === 'resultsMain';
                const scorePct = isMain ? mainPercent : (reviewIds.length ? (reviewFixedCount / reviewIds.length) * 100 : 0);
                return (
                    <div className="min-h-screen flex items-center justify-center p-6">
                        <div className="bg-white w-full max-w-md rounded-3xl shadow-xl p-8 text-center space-y-6 border">
                            <CheckCircle className="w-16 h-16 mx-auto text-green-500" />
                            <h1 className="text-2xl font-bold">{isMain ? 'Quiz Results' : 'Review Results'}</h1>
                            <div className="text-5xl font-black text-blue-600">{scorePct.toFixed(0)}%</div>

                            {isMain ? (
                                <>
                                    <p className="text-slate-500 font-medium">{mainCorrect} / {allIds.length} Correct</p>
                                    <div className="text-sm font-bold text-slate-700">
                                        Result: {mainPercent >= (config?.passThreshold || 65) ? 'Сдал' : 'Не сдал'}
                                    </div>
                                    <div className="text-xs text-slate-400 font-semibold">Порог: {config?.passThreshold || 65}%</div>
                                    {!repeatWrongUntilCorrect && reviewIds.length > 0 && (
                                        <button onClick={startReviewWrong} className="w-full py-3 bg-amber-500 text-white rounded-xl font-bold hover:bg-amber-600">
                                            Review wrong answers
                                        </button>
                                    )}
                                </>
                            ) : (
                                <p className="text-slate-500 font-medium">{reviewFixedCount} fixed / {reviewIds.length} reviewed</p>
                            )}

                            <button onClick={requestRestart} className="w-full py-3 bg-blue-600 text-white rounded-xl font-bold hover:bg-blue-700">Start Again</button>
                        </div>
                    </div>
                );
            }

            // ---- main UI (single-file components inline) ----
            const StatusDot = ({ status }) => {
                const badge =
                    status === 'correct'
                        ? 'bg-green-100 text-green-700 border-green-200'
                        : status === 'wrong'
                            ? 'bg-red-100 text-red-700 border-red-200'
                            : 'bg-slate-100 text-slate-500 border-slate-200';
                const Icon = status === 'correct' ? CheckCircle : (status === 'wrong' ? XCircle : HelpCircle);
                return (
                    <div className={`w-7 h-7 rounded-full border flex items-center justify-center ${badge}`} title={status}>
                        <Icon className="w-4 h-4" />
                    </div>
                );
            };

            const filteredKnowledgeQuestions = useMemo(() => {
                const q = (knowledgeQuery || '').trim().toLowerCase();
                if (!q) return questions;
                return questions.filter(qq => {
                    const hay = [qq.id, qq.question, ...(qq.options || [])].filter(Boolean).join(' ').toLowerCase();
                    return hay.includes(q);
                });
            }, [knowledgeQuery, questions]);

            const canSubmit = !isLocked && ((answersById[currentId] || []).length === requiredSelections);
            const canNext = !isLast; // Allow navigation to next question at any time
            // In exam mode, allow finish on last question even if not locked
            const canFinish = (examMode && phase === 'main' && isLast) || (isLocked && isLast);
            const submitLabel = isLocked ? 'Locked' : 'Submit';
            const submitStyle = isLocked
                ? 'bg-slate-100 text-slate-400 cursor-default'
                : 'bg-blue-600 text-white hover:bg-blue-700 shadow-md active:scale-95';

            return (
                <div className="min-h-screen flex flex-col items-center">
                    <div className="w-full max-w-4xl bg-white shadow-xl md:my-8 md:rounded-3xl flex flex-col overflow-hidden border border-slate-200 md:h-[85vh] relative">
                        {confirmState.open && (
                            <div className="absolute inset-0 z-50 flex items-center justify-center p-6 bg-black/30">
                                <div className="w-full max-w-sm bg-white rounded-2xl border border-slate-200 shadow-2xl p-6 space-y-4">
                                    <div className="text-lg font-extrabold text-slate-800">{confirmState.title}</div>
                                    <div className="text-sm text-slate-500">{confirmState.message}</div>
                                    <div className="flex items-center justify-end gap-3 pt-2">
                                        <button
                                            onClick={closeConfirm}
                                            className="px-4 py-2 rounded-xl bg-slate-100 text-slate-700 font-bold hover:bg-slate-200"
                                        >
                                            Cancel
                                        </button>
                                        <button
                                            onClick={confirmYes}
                                            className="px-4 py-2 rounded-xl bg-red-600 text-white font-bold hover:bg-red-700"
                                        >
                                            Continue
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Result Modal (for normal mode finish) */}
                        {resultModal.open && (
                            <div className="absolute inset-0 z-50 flex items-center justify-center p-6 bg-black/30 overflow-y-auto">
                                <div className={`w-full ${resultModal.categoryStats ? 'max-w-2xl' : 'max-w-sm'} bg-white rounded-2xl border border-slate-200 shadow-2xl p-8 space-y-6`}>
                                    <div className="text-center">
                                        {resultModal.score >= (config?.passThreshold || 65) ? (
                                            <CheckCircle className="w-16 h-16 mx-auto text-green-500" />
                                        ) : (
                                            <XCircle className="w-16 h-16 mx-auto text-red-500" />
                                        )}
                                        <h1 className="text-2xl font-bold mt-4">
                                            {resultModal.score >= 100 ? 'Perfect / All correct' : (examMode ? 'Exam Results' : 'Quiz Results')}
                                        </h1>
                                        <div className="text-5xl font-black text-blue-600">{resultModal.score.toFixed(0)}%</div>
                                        <p className="text-slate-500 font-medium">
                                            {resultModal.correct} / {resultModal.total} Correct
                                        </p>
                                        {resultModal.score < 100 && (
                                            <div className="text-sm font-bold text-slate-700">
                                                Result: {resultModal.score >= (config?.passThreshold || 65) ? 'Passed' : 'Failed'}
                                            </div>
                                        )}
                                    </div>

                                    {/* Category Statistics for Exam Mode */}
                                    {resultModal.categoryStats && Object.keys(resultModal.categoryStats).length > 0 && (
                                        <div className="border-t border-slate-200 pt-6">
                                            <h2 className="text-lg font-bold text-slate-800 mb-4">Results by Category</h2>
                                            <div className="space-y-2 max-h-64 overflow-y-auto">
                                                {Object.entries(resultModal.categoryStats)
                                                    .sort((a, b) => b[1].percent - a[1].percent)
                                                    .map(([category, stats]) => (
                                                        <div key={category} className="p-3 bg-slate-50 rounded-lg border border-slate-200">
                                                            <div className="flex items-center justify-between mb-1">
                                                                <span className="text-sm font-bold text-slate-700">
                                                                    {formatCategoryName(category, config?.categoryDisplayNames || {})}
                                                                </span>
                                                                <span className="text-sm font-bold text-blue-600">
                                                                    {stats.percent.toFixed(0)}%
                                                                </span>
                                                            </div>
                                                            <div className="text-xs text-slate-500">
                                                                {stats.correct} / {stats.total} correct
                                                            </div>
                                                            <div className="mt-2 h-2 bg-slate-200 rounded-full overflow-hidden">
                                                                <div 
                                                                    className="h-full bg-blue-500 transition-all"
                                                                    style={{ width: `${stats.percent}%` }}
                                                                />
                                                            </div>
                                                        </div>
                                                    ))}
                                            </div>
                                        </div>
                                    )}

                                    <div className="flex items-center justify-center gap-3 pt-2 border-t border-slate-200">
                                        {resultModal.wrongAnswers && resultModal.wrongAnswers.length > 0 && (
                                            <button
                                                onClick={() => setWrongAnswersModal({ open: true })}
                                                className="px-4 py-2 rounded-xl bg-amber-500 text-white font-bold hover:bg-amber-600"
                                            >
                                                View Wrong Answers ({resultModal.wrongAnswers.length})
                                            </button>
                                        )}
                                        <button
                                            onClick={() => setResultModal({ open: false, score: 0, correct: 0, total: 0, categoryStats: null, wrongAnswers: null })}
                                            className="px-4 py-2 rounded-xl bg-slate-100 text-slate-700 font-bold hover:bg-slate-200"
                                        >
                                            Close
                                        </button>
                                        <button
                                            onClick={() => {
                                                setResultModal({ open: false, score: 0, correct: 0, total: 0, categoryStats: null, wrongAnswers: null });
                                                onRestart();
                                            }}
                                            className="px-4 py-2 rounded-xl bg-blue-600 text-white font-bold hover:bg-blue-700"
                                        >
                                            Start new test
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Wrong Answers Modal */}
                        {wrongAnswersModal.open && resultModal.wrongAnswers && (
                            <div className="absolute inset-0 z-50 flex items-center justify-center p-6 bg-black/30 overflow-y-auto">
                                <div className="w-full max-w-4xl bg-white rounded-2xl border border-slate-200 shadow-2xl p-8 space-y-6 max-h-[90vh] overflow-y-auto">
                                    <div className="flex items-center justify-between border-b border-slate-200 pb-4">
                                        <h2 className="text-2xl font-bold text-slate-800">Incorrect Answers</h2>
                                        <button
                                            onClick={() => setWrongAnswersModal({ open: false })}
                                            className="px-4 py-2 rounded-xl bg-slate-100 text-slate-700 font-bold hover:bg-slate-200"
                                        >
                                            Close
                                        </button>
                                    </div>
                                    <div className="space-y-6">
                                        {resultModal.wrongAnswers.map((qa, idx) => (
                                            <div key={idx} className="p-6 border border-slate-200 rounded-xl bg-slate-50">
                                                <div className="flex items-start justify-between mb-3">
                                                    <h3 className="font-bold text-sm flex-1">
                                                        {qa.id ? `${qa.id} — ` : ''}{qa.question}
                                                    </h3>
                                                    {qa.category && (
                                                        <span className="px-3 py-1 text-[10px] font-bold text-blue-700 bg-blue-100 rounded-full whitespace-nowrap ml-2">
                                                            {formatCategoryName(qa.category)}
                                                        </span>
                                                    )}
                                                </div>
                                                <div className="grid grid-cols-1 md:grid-cols-2 gap-2 text-[11px] mb-4">
                                                    {qa.options.map((opt, oi) => {
                                                        const isUserAnswer = qa.userAnswer.includes(oi);
                                                        const isCorrect = qa.correctAnswer.includes(oi);
                                                        let bgClass = 'bg-white border-slate-100 text-slate-400';
                                                        if (isCorrect) {
                                                            bgClass = 'bg-green-100 border-green-200 text-green-800 font-bold';
                                                        } else if (isUserAnswer) {
                                                            bgClass = 'bg-red-100 border-red-200 text-red-800 font-bold';
                                                        }
                                                        return (
                                                            <div key={oi} className={`p-3 rounded-lg border flex justify-between items-center ${bgClass}`}>
                                                                <span>{opt}</span>
                                                                {isCorrect && <CheckCircle className="w-3 h-3 text-green-700" />}
                                                                {isUserAnswer && !isCorrect && <XCircle className="w-3 h-3 text-red-700" />}
                                                            </div>
                                                        );
                                                    })}
                                                </div>
                                                {qa.explanation && (
                                                    <div className="text-[10px] text-slate-500 italic p-3 bg-white rounded-xl border border-slate-100">
                                                        <strong>Explanation:</strong> {qa.explanation}
                                                    </div>
                                                )}
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Skipped Questions Modal */}
                        {skippedModal.open && (
                            <div className="absolute inset-0 z-50 flex items-center justify-center p-6 bg-black/30">
                                <div className="w-full max-w-sm bg-white rounded-2xl border border-slate-200 shadow-2xl p-6 space-y-4">
                                    <div className="text-lg font-extrabold text-slate-800">Пропущенные вопросы</div>
                                    <div className="text-sm text-slate-500">
                                        Есть пропущенные вопросы. Перейти к первому?
                                    </div>
                                    <div className="flex items-center justify-end gap-3 pt-2">
                                        <button
                                            onClick={() => setSkippedModal({ open: false })}
                                            className="px-4 py-2 rounded-xl bg-slate-100 text-slate-700 font-bold hover:bg-slate-200"
                                        >
                                            Cancel
                                        </button>
                                        <button
                                            onClick={() => {
                                                const unansweredIdx = findFirstUnansweredIndex(allIds);
                                                if (unansweredIdx >= 0) {
                                                    goToIndex(unansweredIdx);
                                                }
                                                setSkippedModal({ open: false });
                                            }}
                                            className="px-4 py-2 rounded-xl bg-blue-600 text-white font-bold hover:bg-blue-700"
                                        >
                                            Go to first skipped
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}
                        <header className="bg-white border-b px-4 py-3 sm:px-6 sm:py-4 flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3">
                            <div className="flex items-center gap-3 flex-wrap">
                                <button onClick={requestRestart} className="text-slate-400 hover:text-red-500 transition-colors" title="Restart Quiz"><RefreshCw /></button>
                                {!examMode && (
                                    <button onClick={() => setTab(t => t === 'quiz' ? 'knowledge' : 'quiz')} className={`p-2 rounded-lg transition-colors ${tab === 'knowledge' ? 'bg-amber-100 text-amber-600' : 'bg-slate-100 text-slate-500 hover:bg-slate-200'}`} title="Knowledge Base"><BookOpen /></button>
                                )}
                                <button onClick={() => setIsQuestionListOpen(v => !v)} className="p-2 rounded-lg bg-slate-100 text-slate-500 hover:bg-slate-200 transition-colors" title="Question list">
                                    List
                                </button>
                                <div className="h-4 w-px bg-slate-200 mx-2" />
                                <span className="text-xs font-bold text-slate-400 uppercase tracking-tight">{config?.testId || 'QUIZ'}</span>
                                {examMode && (
                                    <span className="px-2 py-1 text-xs font-bold bg-red-100 text-red-700 rounded-full">EXAM MODE</span>
                                )}
                            </div>
                            <div className="flex items-center gap-3 flex-wrap justify-between sm:justify-end">
                                <div className={`flex items-center gap-2 text-xs font-bold ${phase === 'main' ? 'text-slate-700' : 'text-slate-300'}`}>
                                    {phase === 'main' ? (
                                        <label className="flex items-center gap-2 cursor-pointer" title={examMode ? 'Switch to Study Mode' : 'Switch to Exam Mode'}>
                                            <span className="text-xs font-bold">Study Mode</span>
                                            <button
                                                type="button"
                                                disabled={phase !== 'main'}
                                                onClick={() => {
                                                    if (!examMode) {
                                                        // Switching to Exam Mode
                                                        requestSetExamMode(true);
                                                    } else {
                                                        // Switching to Study Mode
                                                        requestSetExamMode(false);
                                                    }
                                                }}
                                                className={`relative inline-flex h-6 w-11 items-center rounded-full border transition-colors ${examMode ? 'bg-blue-600 border-blue-600' : 'bg-slate-200 border-slate-200'} ${phase !== 'main' ? 'opacity-50 cursor-not-allowed' : ''}`}
                                                aria-pressed={examMode}
                                            >
                                                <span className={`inline-block h-5 w-5 transform rounded-full bg-white transition-transform ${examMode ? 'translate-x-5' : 'translate-x-1'}`} />
                                            </button>
                                            <span className="text-xs font-bold">Exam Mode</span>
                                        </label>
                                    ) : (
                                        <span className="text-xs">
                                            {examMode ? 'Exam Mode' : 'Study Mode'}
                                        </span>
                                    )}
                                </div>
                                <div className="flex items-center gap-2 text-xs font-bold text-slate-400">
                                    <span className="hidden sm:inline">Set:</span>
                                    <select value={quizSize} onChange={(e) => requestSetQuizSize(e.target.value)} className="bg-slate-100 border border-slate-200 rounded-lg px-2 py-2 sm:py-1 text-slate-600">
                                        {(config?.quizSizes || [5, 20, 40, 80, 275]).map(s => <option key={s} value={String(s)}>{s === (config?.quizSizes || [])[(config?.quizSizes || []).length - 1] ? 'All' : s}</option>)}
                                    </select>
                                </div>
                                <div className="text-xs font-bold text-slate-400">
                                    {phase === 'repeat'
                                        ? `Wrong ${safeIndex + 1} / ${activeQuestions.length} • Remaining: ${repeatRemainingIds.length}`
                                        : (phase === 'review'
                                            ? `Review ${safeIndex + 1} / ${activeQuestions.length}`
                                            : `Q ${safeIndex + 1} / ${activeQuestions.length}`)}
                                </div>
                                {typeof timeLeftSec === 'number' && (
                                    <div className="text-xs font-black text-slate-500 bg-slate-100 border border-slate-200 rounded-lg px-2 py-1 tabular-nums" title="Time left">
                                        {formatTime(timeLeftSec)}
                                    </div>
                                )}
                            </div>
                        </header>

                        <div className="flex-1 flex overflow-hidden">
                            <div className="flex-1 overflow-hidden flex flex-col">
                                {tab === 'quiz' ? (
                                    <>
                                        <div className="flex-1 overflow-y-auto flex flex-col">
                                            <div className="p-8 bg-slate-50/50 space-y-4 border-b border-slate-100">
                                                <div className="text-[10px] font-black uppercase text-blue-600 tracking-widest">{currentQuestion?.type} CHOICE</div>
                                                <h2 className="text-xl font-bold leading-tight">{currentQuestion?.question || ''}</h2>
                                                <div className="text-xs font-semibold text-slate-500">
                                                    {currentQuestion?.type === 'multiple'
                                                        ? `Select exactly ${requiredSelections} option${requiredSelections === 1 ? '' : 's'}.`
                                                        : 'Select 1 option.'}
                                                </div>
                                            </div>

                                            <div className="p-8 bg-white space-y-3">
                                                {currentOptions.map((opt, i) => {
                                                    const selected = (answersById[currentId] || []).includes(i);
                                                    const correct = currentCorrectIndices.includes(i);
                                                    let cls = "border-slate-200 hover:border-blue-300";
                                                    // In exam mode, hide correctness indicators during test
                                                    if (examMode && phase === 'main') {
                                                        if (selected) {
                                                            cls = "border-blue-600 bg-blue-50 ring-1 ring-blue-600";
                                                        }
                                                    } else {
                                                        if (isLocked) {
                                                            if (correct) cls = "border-green-500 bg-green-50";
                                                            else if (selected) cls = "border-red-500 bg-red-50";
                                                            else cls = "border-slate-100 opacity-40";
                                                        } else if (isHintActive && correct) {
                                                            cls = "border-green-500 bg-green-50";
                                                        } else if (selected) {
                                                            cls = "border-blue-600 bg-blue-50 ring-1 ring-blue-600";
                                                        }
                                                    }
                                                    const showCorrect = !examMode && (isLocked || isHintActive) && correct;
                                                    // In exam mode, allow changing answers even after submit
                                                    const disableSelect = (isLocked && !(examMode && phase === 'main')) || (currentQuestion?.type === 'multiple' && !selected && (answersById[currentId] || []).length >= requiredSelections);
                                                    return (
                                                        <button
                                                            key={i}
                                                            disabled={disableSelect}
                                                            onClick={() => onToggleOption(i)}
                                                            className={`w-full text-left p-4 rounded-xl border-2 transition-all flex items-start gap-3 ${cls} ${(!isLocked && disableSelect) ? 'opacity-60 cursor-not-allowed' : ''}`}
                                                        >
                                                            <div className={`mt-1 w-4 h-4 rounded border flex-shrink-0 flex items-center justify-center ${showCorrect ? '!bg-green-500 !border-green-500' : (selected ? 'bg-blue-600 border-blue-600' : 'bg-white border-slate-300')}`}>
                                                                {(selected || showCorrect) && <CheckCircle className="w-3.5 h-3.5 text-white" />}
                                                            </div>
                                                            <span className="text-sm font-semibold">{opt}</span>
                                                        </button>
                                                    );
                                                })}

                                                {isLocked && !examMode && (
                                                    <div className="mt-6 p-4 bg-blue-50 rounded-xl border border-blue-100 text-[11px] text-blue-800 italic leading-relaxed">
                                                        <div className="flex items-center gap-1 mb-1 not-italic font-bold"><Info /> Explanation:</div>
                                                        {currentQuestion?.explanation || "No additional explanation available."}
                                                    </div>
                                                )}

                                                {!isLocked && !examMode && (
                                                    <button
                                                        onClick={onShowHint}
                                                        disabled={isHintActive}
                                                        className={`w-full py-2 text-[10px] font-bold uppercase tracking-widest flex items-center justify-center gap-2 transition-colors ${isHintActive ? 'text-slate-300 cursor-default' : 'text-slate-400 hover:text-blue-500'}`}
                                                    >
                                                        <Eye /> Show Answers (hint)
                                                    </button>
                                                )}
                                            </div>
                                        </div>

                                        <footer className="bg-white border-t p-6 flex items-center justify-between gap-4">
                                            <button
                                                onClick={() => goToIndex(Math.max(0, safeIndex - 1))}
                                                disabled={safeIndex === 0}
                                                className={`p-3 rounded-xl transition-colors ${safeIndex === 0 ? 'bg-slate-100 text-slate-300 cursor-default' : 'bg-slate-100 hover:bg-slate-200'}`}
                                            >
                                                <ChevronLeft />
                                            </button>

                                            <button
                                                onClick={onSubmit}
                                                disabled={!canSubmit}
                                                className={`flex-1 py-3 rounded-xl font-bold transition-all ${submitStyle}`}
                                            >
                                                {submitLabel}
                                            </button>

                                            {isLast ? (
                                                // In study mode, Finish is hidden (auto-advances to next cycle or perfect)
                                                phase !== 'repeat' && (
                                                    <button
                                                        onClick={onFinish}
                                                        disabled={!canFinish}
                                                        className={`p-3 rounded-xl transition-colors ${canFinish ? 'bg-blue-600 text-white hover:bg-blue-700 shadow-md' : 'bg-slate-100 text-slate-300 cursor-default'}`}
                                                        title="Finish"
                                                    >
                                                        Finish
                                                    </button>
                                                )
                                            ) : (
                                                <button
                                                    onClick={() => goToIndex(Math.min(activeQuestions.length - 1, safeIndex + 1))}
                                                    disabled={!canNext}
                                                    className={`p-3 rounded-xl transition-colors ${canNext ? 'bg-blue-600 text-white hover:bg-blue-700 shadow-md' : 'bg-slate-100 text-slate-300 cursor-default'}`}
                                                    title="Next"
                                                >
                                                    <ChevronRight />
                                                </button>
                                            )}
                                        </footer>
                                    </>
                                ) : (
                                    <div className="flex-1 overflow-y-auto bg-white">
                                        <div className="sticky top-0 z-10 bg-white p-8 pb-4 border-b border-slate-100">
                                            <div className="flex flex-col md:flex-row md:items-end md:justify-between gap-4">
                                                <div>
                                                    <h1 className="text-2xl font-bold text-slate-800">Knowledge Base - Selected Questions</h1>
                                                    <div className="text-xs font-semibold text-slate-400 mt-1">
                                                        Showing {filteredKnowledgeQuestions.length} / {questions.length}
                                                    </div>
                                                </div>
                                                <div className="w-full md:w-96">
                                                    <input
                                                        value={knowledgeQuery}
                                                        onChange={(e) => setKnowledgeQuery(e.target.value)}
                                                        placeholder="Search (id / question / option)…"
                                                        className="w-full px-4 py-3 rounded-xl border border-slate-200 bg-slate-50 focus:bg-white focus:outline-none focus:ring-2 focus:ring-blue-200"
                                                    />
                                                </div>
                                            </div>
                                        </div>

                                        <div className="p-8 pt-6 space-y-6">
                                            {filteredKnowledgeQuestions.map((q, idx) => {
                                                // Find question index in activeIds for navigation
                                                const questionIndexInActive = activeIds.findIndex(id => id === q.id);
                                                const canNavigate = questionIndexInActive >= 0;
                                                const isCurrentQuestion = q.id === currentId;
                                                
                                                return (
                                                <div 
                                                    key={q.id || idx} 
                                                    ref={el => { if (el && q.id) knowledgeQuestionRefs.current[q.id] = el; }}
                                                    className={`p-6 border rounded-2xl transition-colors ${isCurrentQuestion ? 'border-blue-400 bg-blue-50 shadow-md' : 'border-slate-100 bg-slate-50/30'} ${canNavigate ? 'cursor-pointer hover:bg-slate-100' : ''}`} 
                                                    onClick={canNavigate ? () => {
                                                        setTab('quiz');
                                                        goToIndex(questionIndexInActive);
                                                    } : undefined}
                                                >
                                                    <div className="flex items-start justify-between gap-3 mb-3">
                                                        <h3 className="font-bold text-sm flex-1">{q.id ? `${q.id} — ` : ''}{q.question}</h3>
                                                        {q.category && (
                                                            <span className="px-3 py-1 text-[10px] font-bold text-blue-700 bg-blue-100 rounded-full whitespace-nowrap">
                                                                {formatCategoryName(q.category)}
                                                            </span>
                                                        )}
                                                    </div>
                                                    <div className="grid grid-cols-1 md:grid-cols-2 gap-2 text-[11px] mb-4">
                                                        {q.options.map((o, oi) => (
                                                            <div key={oi} className={`p-3 rounded-lg border flex justify-between items-center ${q.correctAnswerIndex.includes(oi) ? 'bg-green-100 border-green-200 text-green-800 font-bold' : 'bg-white border-slate-100 text-slate-400'}`}>
                                                                <span>{o}</span>
                                                                {q.correctAnswerIndex.includes(oi) && <CheckCircle className="w-3 h-3" />}
                                                            </div>
                                                        ))}
                                                    </div>
                                                    <div className="text-[10px] text-slate-500 italic p-3 bg-white rounded-xl border border-slate-100">
                                                        <strong>Note:</strong> {q.explanation || "No additional explanation available."}
                                                    </div>
                                                </div>
                                                );
                                            })}
                                        </div>
                                    </div>
                                )}
                            </div>

                            {/* Sidebar (desktop) */}
                            {isQuestionListOpen && (
                                <aside className="hidden md:flex md:flex-col w-96 border-l border-slate-200 bg-white">
                                    <div className="p-5 border-b border-slate-100 flex items-center justify-between">
                                        <div>
                                            <div className="text-sm font-extrabold text-slate-800">Question list</div>
                                            <div className="text-xs font-semibold text-slate-400 mt-1">
                                                Correct {activeCorrectCount} / {activeIds.length}
                                                {phase === 'repeat' ? ` • Remaining: ${repeatRemainingIds.length}` : ''}
                                            </div>
                                        </div>
                                        <button onClick={() => setIsQuestionListOpen(false)} className="px-3 py-2 rounded-lg bg-slate-100 text-slate-600 font-bold text-xs hover:bg-slate-200">
                                            Close
                                        </button>
                                    </div>
                                    <div className="flex-1 overflow-y-auto p-3 space-y-2">
                                        {activeIds.map((id, idx) => {
                                            const st = getStatus(id);
                                            const isActive = id === currentId;
                                            const qText = (questionById?.[id]?.question || '').trim();
                                            const short = qText.length > 80 ? qText.slice(0, 80) + '…' : qText;
                                            // Hide status in exam mode during main phase
                                            const showStatus = !(examMode && phase === 'main');
                                            return (
                                                <button
                                                    key={id}
                                                    onClick={() => goToIndex(idx)}
                                                    className={`w-full text-left p-3 rounded-xl border transition-colors ${isActive ? 'border-blue-400 bg-blue-50' : 'border-slate-100 hover:border-slate-200 hover:bg-slate-50'}`}
                                                >
                                                    <div className="flex items-center justify-between gap-3">
                                                        <div className="text-xs font-black text-slate-600">
                                                            {phase === 'review'
                                                                ? `Review #${idx + 1}`
                                                                : (phase === 'repeat'
                                                                    ? `Wrong #${idx + 1}`
                                                                    : `#${idx + 1}`)}
                                                            {id ? ` • ${id}` : ''}
                                                        </div>
                                                        {showStatus && <StatusDot status={st} />}
                                                    </div>
                                                    {short && <div className="mt-2 text-[11px] text-slate-500 leading-snug">{short}</div>}
                                                </button>
                                            );
                                        })}
                                    </div>
                                </aside>
                            )}
                        </div>

                        {/* Mobile inline panel (no overlay) */}
                        {isQuestionListOpen && (
                            <div className="md:hidden border-t border-slate-200 bg-white max-h-72 overflow-y-auto">
                                <div className="p-4 border-b border-slate-100 flex items-center justify-between">
                                    <div>
                                        <div className="text-sm font-extrabold text-slate-800">Question list</div>
                                        <div className="text-xs font-semibold text-slate-400 mt-1">
                                            Correct {activeCorrectCount} / {activeIds.length}
                                            {phase === 'repeat' ? ` • Remaining: ${repeatRemainingIds.length}` : ''}
                                        </div>
                                    </div>
                                    <button onClick={() => setIsQuestionListOpen(false)} className="px-3 py-2 rounded-lg bg-slate-100 text-slate-600 font-bold text-xs hover:bg-slate-200">
                                        Close
                                    </button>
                                </div>
                                <div className="p-3 space-y-2">
                                    {activeIds.map((id, idx) => {
                                        const st = getStatus(id);
                                        const isActive = id === currentId;
                                        // Hide status in exam mode during main phase
                                        const showStatus = !(examMode && phase === 'main');
                                        return (
                                            <button
                                                key={id}
                                                onClick={() => goToIndex(idx)}
                                                className={`w-full text-left p-3 rounded-xl border transition-colors ${isActive ? 'border-blue-400 bg-blue-50' : 'border-slate-100 hover:border-slate-200 hover:bg-slate-50'}`}
                                            >
                                                <div className="flex items-center justify-between gap-3">
                                                    <div className="text-xs font-black text-slate-600">
                                                        {phase === 'review'
                                                            ? `Review #${idx + 1}`
                                                            : (phase === 'repeat'
                                                                ? `Wrong #${idx + 1}`
                                                                : `#${idx + 1}`)}
                                                        {id ? ` • ${id}` : ''}
                                                    </div>
                                                    {showStatus && <StatusDot status={st} />}
                                                </div>
                                            </button>
                                        );
                                    })}
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
